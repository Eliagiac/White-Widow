<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Chess Engine UCI</name>
    </assembly>
    <members>
        <member name="T:Utilities.Zobrist">
            <summary>
            A collection of constant keys used to update the board's Zobrist key.
            </summary>
        </member>
        <member name="M:Utilities.Zobrist.CalculateZobristKey">
            <summary>
            Generate a unique key based on the current board state. <br />
            Should only be used on board initialization.
            </summary>
        </member>
        <member name="M:Board.UpdateSquares">
            <summary>
            Update the list representation of the board
            </summary>
        </member>
        <member name="M:Board.UpdateBitboards">
            <summary>
            Update the bitboards based on the Squares list (discontinued)
            </summary>
        </member>
        <member name="T:Engine">
            <summary>The <see cref="T:Engine"/> class contains the main features of the engine.</summary>
        </member>
        <member name="F:Engine.Null">
            <summary>Represents a value that is either not usable or incorrect.</summary>
        </member>
        <member name="F:Engine.Infinity">
            <summary>The maximum evaluation of any position.</summary>
        </member>
        <member name="F:Engine.Checkmate">
            <summary>The score given to a position with checkmate on the board.</summary>
            <remarks>Positions with a forced mating sequence are given a score of
            <see cref="F:Engine.Checkmate"/> - <c>distance from mate</c>. For example, <c>mate in 5</c> = <c>31995</c>.</remarks>
        </member>
        <member name="F:Engine.Draw">
            <summary>The evaluation of a drawn position or stalemate.</summary>
        </member>
        <member name="F:Engine.s_searchStopwatch">
            <summary><see cref="T:System.Diagnostics.Stopwatch"/> that keeps track of the total time taken by the current search.</summary>
            <remarks>Note that it is not reset on different iterations of iterative deepening.</remarks>
        </member>
        <member name="F:Engine.s_lateMoveThresholds">
            <summary>Minimum move index to use late move reductions, depending on total move count.</summary>
        </member>
        <member name="F:Engine.s_futilityMargin">
            <summary>If the evaluation is too low compared to alpha (by at least <c><see cref="F:Engine.s_futilityMargin"/>[Improving 0/1][Depth]</c>) more moves will be skipped.</summary>
            <remarks>The margin is lower if the evaluation has improved since the player's last turn, 
            and is directly proportional to the depth. </remarks>
        </member>
        <member name="F:Engine.s_aspirationWindowsMultipliers">
            <summary>Alpha and beta aspiration window increase factor.</summary>
        </member>
        <member name="F:Engine.s_lateMoveDepthReductions">
            <summary>Depth reduction for late moves depending on the search depth and the current move number.</summary>
            <remarks>Later moves will receive greater depth reductions.</remarks>
        </member>
        <member name="F:Engine.s_killerMoves">
            <summary>Killer moves are quiet moves that caused a beta cutoff, indexed by <c>[KillerMoveIndex, Ply]</c>.<br />
            If the same move is found in another position at the same ply, it will be prioritized.</summary>
            <remarks>2 killer moves are stored at each ply. Storing more would increase the complexity of adding a new move.</remarks>
        </member>
        <member name="F:Engine.s_historyHeuristics">
            <summary>Bonus based on the success of a move in other positions.</summary>
            <remarks>Moves are identified using butterfly boards (https://www.chessprogramming.org/Butterfly_Boards) with [ColorIndex][StartSquareIndex, TargetSquareIndex].</remarks>
        </member>
        <member name="P:Engine.WasSearchAborted">
            <summary>If the search was abruptly interrupted, the returned values will be unusable.</summary>
        </member>
        <member name="P:Engine.MainLine">
            <summary>The best move found by the engine, and the best play sequence that follows it.</summary>
        </member>
        <member name="M:Engine.Search(Node,System.Int32,System.Int32,System.Int32,Line@,System.Boolean,System.UInt64,System.Boolean)">
            <summary>
            The Search function goes through every legal move,
            then recursively calls itself on each of the opponent's responses
            until the depth reaches 0. <br /> Finally, the positions reached are evaluated.
            The path that leads to the best "forced evaluation" is then chosoen. <br />
            The greater the depth, the further into the future the computer will be able to see,
            possibly finding more advanced tactics and better moves.
            </summary>
            <remarks>
            The search tree is made up of search nodes.
            Each node represents a certain position on the board,
            reached after a specific sequence of moves (called a line). <br />
            The parent of a node is the node above it in the tree, closer to the root.
            The children of a node are all the nodes reached after 1 move, the grandchildren after 2 moves and so on. <br />
            Sibling nodes are nodes at the same distance from the root (or <c>ply</c>). <br />
            Pruning a branch means returning the search early in a node, speeding up the search in the parent node.
            </remarks>
            <param name="depth">The remaining depth to search before evaluating the positions reached.</param>
            <param name="alpha">The lower bound of the evaluation</param>
        </member>
        <member name="M:Engine.QuiescenceSearch(Node,System.Int32,System.Int32,Line@)">
            <summary>
            The QuiescenceSearch function extends the normal Search, evaluating all legal captures.
            </summary>
        </member>
        <member name="M:Engine.OrderMoves(System.Collections.Generic.List{Move},System.Int32)">
            <summary>
            Order <paramref name="moves"/> based on the likelihood of a move being strong in the current position.
            </summary>
            <param name="moves">Move list to order</param>
            <param name="ply">Current ply in the search tree. Used to compare killer moves</param>
        </member>
        <member name="M:Engine.IsDrawByRepetition(System.UInt64)">
            <summary>If a position is reached three times, it's a draw.</summary>
        </member>
        <member name="M:Engine.IsDrawByInsufficientMaterial">
            <summary>If there is not enough material on the board for either player to checkate the opponent, it's a draw.</summary>
        </member>
        <member name="T:Node">
            <summary>
            The Node class holds all useful information about a node in the search tree.
            Given a reference to the root node of a tree, the entire tree can be accessed.
            </summary>
        </member>
        <member name="F:Node.Ply">
            <summary>
            Depth navigated along this node's branch.
            </summary>
        </member>
        <member name="F:Node.SearchType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Node.NodeType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Node.Extensions">
            <summary>
            Extension count from the root to this node.
            </summary>
        </member>
        <member name="F:Node.Evaluation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Node.StaticEvaluation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Node.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Node.Children">
            <summary>
            
            </summary>
        </member>
        <member name="P:Node.Child">
            <summary>
            The last child that was added.
            </summary>
        </member>
        <member name="M:Node.op_Addition(Node,System.Int32)">
            <summary>
            Navigate down the tree from <paramref name="node"/> following the current path <paramref name="depth"/> times. <br />
            Any missing children will be added as necessary. <br />
            Note: the behaviour changes if the required child is missing at the end: the CurrentChildIndex of the parent of the last node will increase by 1. <br />
            Note: an alternative approach may be to use recursion.
            </summary>
            <param name="node"></param>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="F:Evaluation.StaticPieceValues">
            <summary>The static value of each piece type, based on gamephase.</summary>
            <remarks>Used to count material when gamephase information isn't yet available. <br />
            Indexed by [PieceType][GamePhase].
            </remarks>
        </member>
        <member name="F:Evaluation.PieceValues">
            <summary>The default value of each piece type.</summary>
            <remarks>Indexed by [PieceType].</remarks>
        </member>
        <member name="F:Evaluation.PassedPawnBonus">
            <summary>Bonus given to pawns that are not blocked by enemy pawns.</summary>
            <remarks>The pawn has a clear path to promotion, and should be valued and protected.<br />
            Indexed by [RankIndex].</remarks>
        </member>
        <member name="F:Evaluation.DoubledPawnPenalty">
            <summary>Penalty for two or more pawns (of the same color) on one file.</summary>
            <remarks>The pawns are less effective because they block each other's movement.</remarks>
        </member>
        <member name="F:Evaluation.IsolatedPawnPenalty">
            <summary>Penalty for a pawn with no friendly pawns on neighbouring files.</summary>
            <remarks>The pawn is more vulnerable, as well as less useful to other pawns.</remarks>
        </member>
        <member name="F:Evaluation.BackwardPawnPenalty">
            <summary>Penalty for a pawn whose stop square is controlled by an enemy pawn, and not defended by any friendly pawns.</summary>
            <remarks>The pawn is likely to never be able to make progress.</remarks>
        </member>
        <member name="F:Evaluation.MaterialImbalancePawnPenalty">
            <summary>Penalty for all pawns based on material imbalance.</summary>
            <remarks>If one side is up material, pieces gain importance.</remarks>
        </member>
        <member name="F:Evaluation.KnightPairBonus">
            <summary>Bonus for having two or more knights.</summary>
            <remarks>The knights gain strength when both are available.<br />
            Indexed by [OpenPosition]</remarks>
        </member>
        <member name="F:Evaluation.BishopPairBonus">
            <summary>Bonus for having two or more bishops.</summary>
            <remarks>The bishops gain strength when both are available.<br />
            Indexed by [OpenPosition]</remarks>
        </member>
        <member name="F:Evaluation.MobilityBonus">
            <summary>Bonus based on how much mobility a piece has.</summary>
            <remarks>Pieces are likely to be stronger if they control many squares.<br />
            Indexed by [PieceType][ControlledSquares]</remarks>
        </member>
        <member name="F:Evaluation.ShieldingPawnBonus">
            <summary>Bonus for pawns protecting the castled king.</summary>
            <remarks>Either directly in front of the king or one square further.<br />
            Indexed by [DistanceFromKing]</remarks>
        </member>
        <member name="F:Evaluation.OpenFileNextToKingPenalty">
            <summary>Penalty for an exposed king.</summary>
            <remarks>A king is more open to attacks if no friendly pawns are in front of it (half-open file), 
            and even worse if there are also no enemy pawns in front of it (open file).<br />
            Indexed by [OpenFile]</remarks>
        </member>
        <member name="T:TT">
            <summary>The <see cref="T:TT"/> (Transposition Table) class stores info on positions that have already been reached by the search function. 
            Information about these entries such as their evaluation can quickly be looked up to avoid calculating it again.</summary>
        </member>
        <member name="F:TT.Entries">
            <summary>A table containing information about specific positions, <br />
            indexed based on the <see cref="F:Board.ZobristKey"/> of the position.</summary>
        </member>
        <member name="F:TT.CurrentEntryIndex">
            <summary>The index of the current position in the <see cref="F:TT.Entries"/> array based on the <see cref="F:Board.ZobristKey"/>.</summary>
            <remarks>Must be updated any time the position changes using <see cref="M:TT.CalculateCurrentEntryIndex"/>.</remarks>
        </member>
        <member name="F:TT.IsEnabled">
            <summary>If the transposition table is disabled, 
            <see cref="M:TT.StoreEvaluation(System.Int32,System.Int32,System.Int32,EvaluationType,Line,System.Int32)"/> will return early.</summary>
        </member>
        <member name="F:TT._tableSize">
            <summary>The size of the <see cref="F:TT.Entries"/> array.</summary>
            <remarks>The default size is 8MB.</remarks>
        </member>
        <member name="M:TT.Resize(System.Int32)">
            <summary>Generate a new transposition table of the specified size (in megabytes).</summary>
            <param name="sizeInMegabytes">The size of the <see cref="F:TT.Entries"/> array in megabytes.</param>
        </member>
        <member name="M:TT.Clear">
            <summary>Reset the <see cref="F:TT.Entries"/> array.</summary>
        </member>
        <member name="M:TT.CalculateCurrentEntryIndex">
            <summary>Update the <see cref="F:TT.CurrentEntryIndex"/> based on the position on the board.</summary>
        </member>
        <member name="P:TT.CurrentEntry">
            <summary>The entry at the <see cref="F:TT.CurrentEntryIndex"/>.</summary>
        </member>
        <member name="T:EvaluationType">
            <summary>
            The score returned by the search may not be the exact evaluation of the position, 
            because of <see href="https://www.chessprogramming.org/Alpha-Beta">Alpha-Beta pruning</see>.
            </summary>
        </member>
        <member name="F:EvaluationType.Exact">
            <summary>The node is a PV-Node.</summary>
            <remarks>The score is the exact evaluation of the position.</remarks>
        </member>
        <member name="F:EvaluationType.LowerBound">
            <summary>The node is a Cut-Node.</summary>
            <remarks>
            A beta-cutoff caused some moves to be skipped,
            so the score is a lower bound of the evaluation
            (the exact evaluation may be higher).
            </remarks>
        </member>
        <member name="F:EvaluationType.UpperBound">
            <summary>The node is an All-Node.</summary>
            <remarks>
            No moves exceeded alpha, so the score 
            is an upper bound of the evaluation
            (the exact evaluation may be lower).
            </remarks>
        </member>
    </members>
</doc>
